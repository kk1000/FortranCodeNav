<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="fortran_codenav_128" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\fortran_codenav_128.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Function_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Function_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Interface_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Interface_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Module_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Module_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Search" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Search.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Subroutine_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Subroutine_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Type_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Type_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="variable_char" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\variable_char.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="variable_float" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\variable_float.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="variable_int" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\variable_int.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="variable_logical" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\variable_logical.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="variable_type" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\variable_type.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="fortran_codenav_64_nobg" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\fortran_codenav_64_nobg.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="intr_abs" xml:space="preserve">
    <value>abs(a) computes the absolute value of a.

Standard:
FORTRAN 77 and later

Class: 
Elemental function

Syntax: 
result = abs(a)

Arguments: 
a - the type of the argument shall be an integer, real, or complex.

Return value:
The return value is of the same type and kind as the argument except the return value is real for a complex argument.
http://fortranwiki.org/fortran/show/abs</value>
  </data>
  <data name="intr_achar" xml:space="preserve">
    <value>achar(i) returns the character located at position i in the ASCII collating sequence.

Standard:
FORTRAN 77 and later, with kind argument Fortran 2003 and later

Class: 
Elemental function

Syntax: 
result = achar(i [, kind])

Arguments: 
i - the type shall be integer.
kind - (optional) an integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type character with a length of one. If the kind argument is present, the return value is of the specified kind and of the default kind otherwise.
http://fortranwiki.org/fortran/show/achar</value>
  </data>
  <data name="intr_acos" xml:space="preserve">
    <value>acos(x) computes the arccosine of x (inverse of cos(x)).

Standard:
FORTRAN 77 and later, for a complex argument Fortran 2008 and later

Class: 
Elemental function

Syntax:
result = acos(x)

Arguments: 
x - The type shall be real with a magnitude that is less than one.

Return value:
The return value is of the same type and kind as x. The real part of the result is in radians and lies in the range 0≤acos(x)≤π.
http://fortranwiki.org/fortran/show/acos</value>
  </data>
  <data name="intr_acosh" xml:space="preserve">
    <value>acosh(x) computes the inverse hyperbolic cosine of x.

Standard:
Fortran 2008 and later

Class: 
Elemental function

Syntax: 
result = acosh(x)

Arguments: 
x - the type shall be real or complex.

Return value:
The return value has the same type and kind as x. If x is complex, the imaginary part of the result is in radians and lies between 0≤Imacosh(x)≤π.
http://fortranwiki.org/fortran/show/acosh</value>
  </data>
  <data name="intr_adjustl" xml:space="preserve">
    <value>adjustl(string) will left adjust a string by removing leading spaces. Spaces are inserted at the end of the string as needed.

Standard:
Fortran 95 and later

Class: 
Elemental function

Syntax: 
result = adjustl(string)

Arguments: 
string - the type shall be character.

Return value:
The return value is of type character and of the same kind as string where leading spaces are removed and the same number of spaces are inserted on the end of string.
http://fortranwiki.org/fortran/show/adjustl</value>
  </data>
  <data name="intr_adjustsr" xml:space="preserve">
    <value>adjustr(string) will right adjust a string by removing trailing spaces. Spaces are inserted at the start of the string as needed.

Standard:
Fortran 95 and later

Class: 
Elemental function

Syntax: 
result = adjustr(string)

Arguments: 
string - the type shall be character.

Return value:
The return value is of type character and of the same kind as string where trailing spaces are removed and the same number of spaces are inserted at the start of string.
http://fortranwiki.org/fortran/show/adjustr</value>
  </data>
  <data name="intr_aimag" xml:space="preserve">
    <value>aimag(z) yields the imaginary part of complex argument z. The imag(z) and imagpart(z) intrinsic functions are provided for compatibility with g77, and their use in new code is strongly discouraged.

Standard:
FORTRAN 77 and later

Class: 
Elemental function

Syntax: 
result = aimag(z)

Arguments: 
z - The type of the argument shall be complex.

Return value:
The return value is of type real with the kind type parameter of the argument.
http://fortranwiki.org/fortran/show/aimag</value>
  </data>
  <data name="intr_aint" xml:space="preserve">
    <value>aint(a [, kind]) truncates its argument to a whole number.

Standard:
FORTRAN 77 and later

Class: 
Elemental function

Syntax: 
result = aint(a [, kind])

Arguments: 
a - the type of the argument shall be real.
kind - (optional) an integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type real with the kind type parameter of the argument if the optional kind is absent; otherwise, the kind type parameter will be given by kind. If the magnitude of x is less than one, aint(x) returns zero. If the magnitude is equal to or greater than one then it returns the largest whole number that does not exceed its magnitude. The sign is the same as the sign of x.
http://fortranwiki.org/fortran/show/aint</value>
  </data>
  <data name="intr_all" xml:space="preserve">
    <value>all(mask [, dim]) determines if all the values are true in mask in the array along dimension dim.

Standard:
Fortran 95 and later

Class: 
Transformational function

Syntax: 
result = all(mask [, dim])

Arguments: 
mask - the type of the argument shall be logical and it shall not be scalar.
dim - (optional) dim shall be a scalar integer with a value that lies between one and the rank of mask.

Return value:
all(mask) returns a scalar value of type logical where the kind type parameter is the same as the kind type parameter of mask. If dim is present, then all(mask, dim) returns an array with the rank of mask minus 1. The shape is determined from the shape of mask where the dim dimension is elided.

all(mask) is true if all elements of mask are true. It also is true if mask has zero size; otherwise, it is false.

If the rank of mask is one, then all(mask, dim) is equivalent to all(mask). If the rank is greater than one, then all(mask, dim) is determined by applying all to the array sections.
http://fortranwiki.org/fortran/show/all</value>
  </data>
  <data name="intr_allocated" xml:space="preserve">
    <value>allocated(array) and allocated(scalar) check the allocation status of array and scalar, respectively.

Standard:
Fortran 95 and later. Note, the scalar= keyword and allocatable scalar entities are available in Fortran 2003 and later.

Class: 
Inquiry function

Syntax: 
result = allocated(array)
result = allocated(scalar)
Arguments: 
array - the argument shall be an allocatable array.
scalar - the argument shall be an allocatable scalar.

Return value:
The return value is a scalar logical with the default logical kind type parameter. If the argument is allocated then the result is .true.; otherwise, it returns .false..
http://fortranwiki.org/fortran/show/allocated</value>
  </data>
  <data name="intr_anint" xml:space="preserve">
    <value>anint(a [, kind]) rounds its argument to the nearest whole number.

Standard:
FORTRAN 77 and later

Class: 
Elemental function

Syntax: 
result = anint(a [, kind])

Arguments: 
a - the type of the argument shall be real.
kind - (optional) an integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type real with the kind type parameter of the argument if the optional kind is absent; otherwise, the kind type parameter will be given by kind. If a is greater than zero, anint(a) returns aint(x + 0.5). If a is less than or equal to zero then it returns aint(x - 0.5).
http://fortranwiki.org/fortran/show/anint</value>
  </data>
  <data name="intr_any" xml:space="preserve">
    <value>any(mask [, dim]) determines if any of the values in the logical array mask along dimension dim are .true..

Standard:
Fortran 95 and later

Class: 
Transformational function

Syntax: 
result = any(mask [, dim])

Arguments: 
mask - the type of the argument shall be logical and it shall not be scalar.
dim - (optional) dim shall be a scalar integer with a value that lies between one and the rank of mask.

Return value:
any(mask) returns a scalar value of type logical where the kind type parameter is the same as the kind type parameter of mask. If dim is present, then any(mask, dim) returns an array with the rank of mask minus 1. The shape is determined from the shape of mask where the dim dimension is elided.

any(mask) is true if any element of mask is true; otherwise, it is false. It also is false if mask has zero size.

If the rank of mask is one, then any(mask, dim) is equivalent to any(mask). If the rank is greater than one, then any(mask, dim) is determined by applying any to the array sections.
http://fortranwiki.org/fortran/show/any</value>
  </data>
  <data name="intr_asin" xml:space="preserve">
    <value>asin(x) computes the arcsine of its x (inverse of sin(x)).

Standard:
FORTRAN 77 and later, for a complex argument Fortran 2008 or later

Class: 
Elemental function

Syntax: 
result = asin(x)

Arguments: 
x - The type shall be either real and a magnitude that is less than or equal to one or be complex.

Return value:
The return value is of the same type and kind as x. The real part of the result is in radians and lies in the range −π/2≤asin(x)≤π/2.
http://fortranwiki.org/fortran/show/asin</value>
  </data>
  <data name="intr_asinh" xml:space="preserve">
    <value>asinh(x) computes the inverse hyperbolic sine of x.

Standard:
Fortran 2008 and later

Class: 
Elemental function

Syntax: 
result = asinh(x)
Arguments: 
x - The type shall be real or complex.

Return value:
The return value is of the same type and kind as x. If x is complex, the imaginary part of the result is in radians and lies between −π/2≤Imasinh(x)≤π/2 -\pi/2.
http://fortranwiki.org/fortran/show/asinh</value>
  </data>
  <data name="intr_associated" xml:space="preserve">
    <value>associated(pointer [, target]) determines the status of the pointer pointer or if pointer is associated with the target target.

Standard:
Fortran 95 and later

Class: 
Inquiry function

Syntax: 
result = associated(pointer [, target])

Arguments: 
pointer - pointer shall have the pointer attribute and it can be of any type.
target - (Optional) target shall be a pointer or a target. It must have the same type, kind type parameter, and array rank as pointer.
The association status of neither pointer nor target shall be undefined.


Return value:
associated(pointer) returns a scalar value of type logical(4). There are several cases:

When the optional target is not present then associated(pointer) is true if pointer is associated with a target; otherwise, it returns false.

If target is present and a scalar target, the result is true if target is not a zero-sized storage sequence and the target associated with pointer occupies the same storage units. If pointer is disassociated, the result is false.

If target is present and an array target, the result is true if target and pointer have the same shape, are not zero-sized arrays, are arrays whose elements are not zero-sized storage sequences, and target and pointer occupy the same storage units in array element order.

As in case 2, the result is false, if pointer is disassociated.

If target is present and an scalar pointer, the result is true if target is associated with pointer, the target associated with target are not zero-sized storage sequences and occupy the same storage units.

The result is false, if either target or pointer is disassociated.

If target is present and an array pointer, the result is true if target associated with pointer and the target associated with target have the same shape, are not zero-sized arrays, are arrays whose elements are not zero-sized storage sequences, and target and pointer occupy the same storage units in array element order. The result is false, if either target or pointer is disassociated.
http://fortranwiki.org/fortran/show/associated</value>
  </data>
  <data name="intr_atan" xml:space="preserve">
    <value>atan(x) computes the arctangent of x.

Standard:
FORTRAN 77 and later; for a complex argument and for two arguments Fortran 2008 or later

Class: 
Elemental function

Syntax: 
result = atan(x)
result = atan(y, x)
Arguments: 
x - The type shall be real or complex; if y is present, x shall be real.
y - Shall be of the same type and kind as x.

Return value:
The return value is of the same type and kind as x. If y is present, the result is identical to atan2(y,x). Otherwise, it the arcus tangent of x, where the real part of the result is in radians and lies in the range −π/2≤Reatan(x)≤π/2.
http://fortranwiki.org/fortran/show/atan</value>
  </data>
  <data name="intr_atomic_add" xml:space="preserve">
    <value>atomic_add(atom, value) atomically adds the value of var to the variable atom. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_add (atom, value [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_add</value>
  </data>
  <data name="intr_atomic_cas" xml:space="preserve">
    <value>atomic_cas compares the variable atom with the value of compare; if the value is the same, atom is set to the value of new. Additionally, old is set to the value of atom that was used for the comparison. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_cas (atom, old, compare, new [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of either integer type with atomic_int_kind kind or logical type with atomic_logical_kind kind.
old - Scalar of the same type and kind as atom.
compare - Scalar variable of the same type and kind as atom.
new - Scalar variable of the same type as atom. If kind is different, the value is converted to the kind of atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_cas</value>
  </data>
  <data name="intr_atomic_define" xml:space="preserve">
    <value>atomic_define(atom, value) defines the variable atom with the value value atomically. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
Fortran 2008 and later; with stat, TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_define (atom, value [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of either integer type with atomic_int_kind kind or logical type with atomic_logical_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_define</value>
  </data>
  <data name="intr_atomic_fetch_add" xml:space="preserve">
    <value>atomic_fetch_add(atom, value, old) atomically stores the value of atom in old and adds the value of var to the variable atom. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_fetch_add(atom, value, old [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind. atomic_logical_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
old - Scalar of the same type and kind as atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_fetch_add</value>
  </data>
  <data name="intr_atomic_fetch_and" xml:space="preserve">
    <value>atomic_fetch_and(atom, value, old) atomically stores the value of atom in old and defines atom with the bitwise and between the values of atom and value. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_fetch_and(atom, value, old [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
old - Scalar of the same type and kind as atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_fetch_and</value>
  </data>
  <data name="intr_atomic_fetch_or" xml:space="preserve">
    <value>atomic_fetch_or(atom, value, old) atomically stores the value of atom in old and defines atom with the bitwise or between the values of atom and value. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_fetch_or(atom, value, old [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
old - Scalar of the same type and kind as atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_fetch_or</value>
  </data>
  <data name="intr_atomic_fetch_xor" xml:space="preserve">
    <value>atomic_fetch_xor(atom, value, old) atomically stores the value of atom in old and defines atom with the bitwise xor between the values of atom and value. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_fetch_xor (atom, value, old [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
old - Scalar of the same type and kind as atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_fetch_xor</value>
  </data>
  <data name="intr_atomic_or" xml:space="preserve">
    <value>atomic_or(atom, value) atomically defines atom with the bitwise or between the values of atom and value. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_or(atom, value [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_or</value>
  </data>
  <data name="intr_atomic_ref" xml:space="preserve">
    <value>atomic_ref(atom, value) atomically assigns the value of the variable atom to value. When stat is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed atom, if the remote image has stopped, it is assigned the value of iso_fortran_env‘s stat_stopped_image and if the remote image has failed, the value stat_failed_image.

Standard:
Fortran 2008 and later; with stat, TS 18508 or later

Class: 
Atomic subroutine

Syntax: 
call atomic_ref(value, atom [, stat])

Arguments: 
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
atom - Scalar coarray or coindexed variable of either integer type with atomic_int_kind kind or logical type with atomic_logical_kind kind.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_ref</value>
  </data>
  <data name="intr_atomic_xor" xml:space="preserve">
    <value>call atomic_xor(atom, value [, stat])
Arguments: 
atom - Scalar coarray or coindexed variable of integer type with atomic_int_kind kind.
value - Scalar of the same type as atom. If the kind is different, the value is converted to the kind of atom.
stat - (optional) Scalar default-kind integer variable.
http://fortranwiki.org/fortran/show/atomic_xor</value>
  </data>
  <data name="Intrinsic_Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Intrinsic_Icon.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="intr_bessel_j0" xml:space="preserve">
    <value>bessel_j0(x) computes the Bessel function of the first kind of order 0 of x.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bessel_j0(x)

Arguments:
x - The type shall be real.

Return value:
The return value is of type real and lies in the range −0.4027...≤Bessel(0,x)≤1. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_j0</value>
  </data>
  <data name="intr_bessel_j1" xml:space="preserve">
    <value>bessel_j1(x) computes the Bessel function of the first kind of order 1 of x.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bessel_j1(x)

Arguments:
x - The type shall be real.

Return value:
The return value is of type real and lies in the range −0.5818...≤Bessel(0,x)≤0.5818. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_j1</value>
  </data>
  <data name="intr_bessel_jn" xml:space="preserve">
    <value>bessel_jn(n, x) computes the Bessel function of the first kind of order n of x. If n and x are arrays, their ranks and shapes shall conform.

bessel_jn(n1, n2, x) returns an array with the Bessel functions of the first kind of the orders n1 to n2.

Standard:
Fortran 2008 and later

Class:
Elemental function, except for the transformational variant bessel_jn(n1, n2, x).

Syntax
result = bessel_jn(n, x)
result = bessel_jn(n1, n2, x)

Arguments:
n - Shall be a scalar or an array of type integer.
n1 - Shall be a non-negative scalar of type integer.
n2 - Shall be a non-negative scalar of type integer.
x - Shall be a scalar or an array of type real. For bessel_jn(n1, n2, x) it shall be scalar.

Return value:
The return value is a scalar of type real. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_jn</value>
  </data>
  <data name="intr_bessel_y0" xml:space="preserve">
    <value>bessel_y0(x) computes the Bessel function of the second kind of order 0 of x.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bessel_y0(x)

Arguments:
x - The type shall be real.

Return value:
The return value is of type real. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_y0</value>
  </data>
  <data name="intr_bessel_y1" xml:space="preserve">
    <value>bessel_y1(x) computes the Bessel function of the second kind of order 1 of x.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bessel_y1(x)

Arguments:
x - The type shall be real.

Return value:
The return value is real. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_y1</value>
  </data>
  <data name="intr_bessel_yn" xml:space="preserve">
    <value>bessel_yn(n, x) computes the Bessel function of the second kind of order n of x. If n and x are arrays, their ranks and shapes shall conform.

bessel_yn(n1, n2, x) returns an array with the Bessel functions of the first kind of the orders n1 to n2.

Standard:
Fortran 2008 and later

Class:
Elemental function, except for the transformational function bessel_yn(n1, n2, x)

Syntax
result = bessel_yn(n, x)
result = bessel_yn(n1, n2, x)

Arguments:
n - Shall be a scalar or an array of type integer.
n1 - Shall be a non-negative scalar of type integer.
n2 - Shall be a non-negative scalar of type integer.
x - Shall be a scalar or an array of type real; for bessel_yn(n1, n2, x) it shall be scalar.

Return value:
The return value is real. It has the same kind as x.
http://fortranwiki.org/fortran/show/bessel_yn</value>
  </data>
  <data name="intr_bge" xml:space="preserve">
    <value>bge(i, j) determines whether an integer is a bitwise greater than or equal to another.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bge(i, j)

Arguments:
i - Shall be of integer type.
j - Shall be of integer type, and of the same kind as i.

Return value:
The return value is of type logical and of the default kind.
http://fortranwiki.org/fortran/show/bge</value>
  </data>
  <data name="intr_bgt" xml:space="preserve">
    <value>bgt(i, j) determines whether an integer is bitwise greater than another.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = bgt(i, j)

Arguments:
i - Shall be of integer type.
j - Shall be of integer type, and of the same kind as i.

Return value:
The return value is of type logical and of the default kind.
http://fortranwiki.org/fortran/show/bgt</value>
  </data>
  <data name="intr_bit_size" xml:space="preserve">
    <value>bit_size(i) returns the number of bits (integer precision plus sign bit) represented by the type of i.

Standard:
Fortran 95 and later

Class:
Inquiry function

Syntax
result = bit_size(i)

Arguments:
i - The type shall be integer.

Return value:
The return value is of type integer
http://fortranwiki.org/fortran/show/bit_size</value>
  </data>
  <data name="intr_ble" xml:space="preserve">
    <value>ble(i, j) determines whether an integer is bitwise less than or equal to another.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = ble(i, j)

Arguments:
i - Shall be of integer type.
j - Shall be of integer type, and of the same kind as i.

Return value:
The return value is of type logical and of the default kind.
http://fortranwiki.org/fortran/show/ble</value>
  </data>
  <data name="intr_blt" xml:space="preserve">
    <value>blt(i, j) determines whether an integer is bitwise less than another.

Standard:
Fortran 2008 and later

Class:
Elemental function

Syntax
result = blt(i, j)

Arguments:
i - Shall be of integer type.
j - Shall be of integer type, and of the same kind as i.

Return value:
The return value is of type logical and of the default kind.
http://fortranwiki.org/fortran/show/blt</value>
  </data>
  <data name="intr_btest" xml:space="preserve">
    <value>btest(i,pos) returns logical .true. if the bit at pos in i is set.

Standard:
Fortran 95 and later

Class:
Elemental function

Syntax
result = btest(i, pos)

Arguments:
i - The type shall be integer.
pos - The type shall be integer. A value of zero refers to the least significant bit.

Return value:
The return value is of type logical.
http://fortranwiki.org/fortran/show/btest</value>
  </data>
  <data name="intr_ceiling" xml:space="preserve">
    <value>ceiling(a) returns the least integer greater than or equal to a.

Standard:
Fortran 95 and later

Class:
Elemental function

Syntax:
result = ceiling(a [, kind])

Arguments:
a - The type shall be real.
kind - (Optional) An integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type integer(kind) if kind is present and a default-kind integer otherwise.
http://fortranwiki.org/fortran/show/ceiling</value>
  </data>
  <data name="intr_char" xml:space="preserve">
    <value>char(i [, kind]) returns the character represented by the integer i.

Standard:
FORTRAN 77 and later

Class:
Elemental function

Syntax:
result = char(i [, kind])

Arguments:
i - The type shall be integer.
kind - (Optional) An integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type character(1)
http://fortranwiki.org/fortran/show/char</value>
  </data>
  <data name="intr_cmplx" xml:space="preserve">
    <value>cmplx(x [, y [, kind]]) returns a complex number where x is converted to the real component. If y is present it is converted to the imaginary component. If y is not present then the imaginary component is set to 0.0. If x is complex then y must not be present.

Standard:
FORTRAN 77 and later

Class:
Elemental function

Syntax:
result = cmplx(x [, y [, kind]])

Arguments:
x - The type may be integer, real, or complex.
y - (Optional; only allowed if x is not complex.) May be integer or real.
kind - (Optional) An integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of complex type, with a kind equal to kind if it is specified. If kind is not specified, the result is of the default complex kind, regardless of the kinds of x and y.
http://fortranwiki.org/fortran/show/cmplx</value>
  </data>
  <data name="intr_command_argument_count" xml:space="preserve">
    <value>command_argument_count returns the number of arguments passed on the command line when the containing program was invoked.

Standard:
Fortran 2003 and later

Class:
Inquiry function

Syntax:
result = command_argument_count()
Arguments:
None


Return value:
The return value is of type integer(4)
http://fortranwiki.org/fortran/show/command_argument_count</value>
  </data>
  <data name="intr_compiler_options" xml:space="preserve">
    <value>compiler_options returns a string with the options used for compiling.

Standard:
Fortran 2008

Class:
Inquiry function of the module iso_fortran_env

Syntax:
str = compiler_options()
Arguments:
None.


Return value:
The return value is a default-kind string with system-dependent length. It contains the compiler flags used to compile the file, which called the compiler_options intrinsic.
http://fortranwiki.org/fortran/show/compiler_options</value>
  </data>
  <data name="intr_conjg" xml:space="preserve">
    <value>conjg(z) returns the conjugate of z. If z is (x, y) then the result is (x, -y)

Standard:
FORTRAN 77 and later

Class:
Elemental function

Syntax:
z = conjg(z)

Arguments:
z - The type shall be complex.

Return value:
The return value is of type complex.
http://fortranwiki.org/fortran/show/conjg</value>
  </data>
  <data name="intr_cos" xml:space="preserve">
    <value>cos(x) computes the cosine of x.

Standard:
FORTRAN 77 and later

Class:
Elemental function

Syntax:
result = cos(x)

Arguments:
x - The type shall be real or complex.

Return value:
The return value is of the same type and kind as x. The real part of the result is in radians. If x is of the type real, the return value lies in the range -1 &lt;= cos(x) &lt;= 1.
http://fortranwiki.org/fortran/show/cos</value>
  </data>
  <data name="intr_cosh" xml:space="preserve">
    <value>cosh(x) computes the hyperbolic cosine of x.

Standard:
FORTRAN 77 and later, for a complex argument Fortran 2008 or later

Class:
Elemental function

Syntax:
x = cosh(x)
Arguments:
x - The type shall be real or complex.

Return value:
The return value has same type and kind as x. If x is complex, the imaginary part of the result is in radians. If x is real, the return value has a lower bound of one, cosh(x)≥1.
http://fortranwiki.org/fortran/show/cosh</value>
  </data>
  <data name="intr_count" xml:space="preserve">
    <value>count(mask [, dim, kind]) Counts the number of .true. elements in a logical mask, or, if the dim argument is supplied, counts the number of elements along each row of the array in the dim direction. If the array has zero size, or all of the elements of mask are .false., then the result is 0.

Standard:
Fortran 95 and later, with kind argument Fortran 2003 and later

Class:
Transformational function

Syntax:
result = count(mask [, dim, kind])
Arguments:
mask - The type shall be logical.
dim - (Optional) The type shall be integer.
kind - (Optional) An integer initialization expression indicating the kind parameter of the result.

Return value:
The return value is of type integer and of kind kind. If kind is absent, the return value is of default integer kind. If dim is present, the result is an array with a rank one less than the rank of array, and a size corresponding to the shape of array with the dim dimension removed.
http://fortranwiki.org/fortran/show/count</value>
  </data>
  <data name="intr_co_broadcast" xml:space="preserve">
    <value>co_broadcast copies the value of argument a on the image with image index source_image to all images in the current team. a becomes defined as if by intrinsic assignment. If the execution was successful and stat is present, it is assigned the value zero. If the execution failed, stat gets assigned a nonzero value and, if present, errmsg gets assigned a value describing the occurred error.

Standard:
TS 18508 or later

Class:
Collective subroutine

Syntax:
call co_broadcast(a, source_image [, stat, errmsg])
Arguments:
a - intent(inout) argument; shall have the same dynamic type and type paramters on all images of the current team. If it is an array, it shall have the same shape on all images.
source_image - a scalar integer expression. It shall have the same the same value on all images and refer to an image of the current team.
stat - (optional) a scalar integer variable
errmsg - (optional) a scalar character variable
http://fortranwiki.org/fortran/show/co_broadcast</value>
  </data>
  <data name="intr_co_max" xml:space="preserve">
    <value>co_max determines element-wise the maximal value of a on all images of the current team. If result_image is present, the maximum values are returned in a on the specified image only and the value of a on the other images become undefined. If result_image is not present, the value is returned on all images. If the execution was successful and stat is present, it is assigned the value zero. If the execution failed, stat gets assigned a nonzero value and, if present, errmsg gets assigned a value describing the occurred error.

Standard:
TS 18508 or later

Class:
Collective subroutine

Syntax:
call co_max(a [, result_image, stat, errmsg])
Arguments:
a - shall be an integer, real or character variable, which has the same type and type parameters on all images of the team.
result_image - (optional) a scalar integer expression; if present, it shall have the same the same value on all images and refer to an image of the current team.
stat - (optional) a scalar integer variable
errmsg - (optional) a scalar character variable
http://fortranwiki.org/fortran/show/co_max</value>
  </data>
  <data name="intr_co_min" xml:space="preserve">
    <value>co_min determines element-wise the minimal value of a on all images of the current team. If result_image is present, the minimal values are returned in a on the specified image only and the value of a on the other images become undefined. If result_image is not present, the value is returned on all images. If the execution was successful and stat is present, it is assigned the value zero. If the execution failed, stat gets assigned a nonzero value and, if present, errmsg gets assigned a value describing the occurred error.

Standard:
TS 18508 or later

Class:
Collective subroutine

Syntax:
call co_min(a [, result_image, stat, errmsg])
Arguments:
a - shall be an integer, real or character variable, which has the same type and type parameters on all images of the team.
result_image - (optional) a scalar integer expression; if present, it shall have the same the same value on all images and refer to an image of the current team.
stat - (optional) a scalar integer variable
errmsg - (optional) a scalar character variable
http://fortranwiki.org/fortran/show/co_min</value>
  </data>
  <data name="intr_co_reduce" xml:space="preserve">
    <value>co_reduce determines element-wise the reduction of the value of a on all images of the current team. The pure function passed as operator is used to pairwise reduce the values of a by passing either the value of a of different images or the result values of such a reduction as argument. If a is an array, the deduction is done element wise. If result_image is present, the result values are returned in a on the specified image only and the value of a on the other images become undefined. If result_image is not present, the value is returned on all images. If the execution was successful and stat is present, it is assigned the value zero. If the execution failed, stat gets assigned a nonzero value and, if present, errmsg gets assigned a value describing the occurred error.

Standard:
TS 18508 or later

Class:
Collective subroutine

Syntax:
call co_reduce(a, operator, [, result_image, stat, errmsg])
Arguments:
a - is an intent(inout) argument and shall be nonpolymorphic. If it is allocatable, it shall be allocated; if it is a pointer, it shall be associated. a shall have the same type and type parameters on all images of the team; if it is an array, it shall have the same shape on all images.
operator - pure function with two scalar nonallocatable arguments, which shall be nonpolymorphic and have the same type and type parameters as a. The function shall return a nonallocatable scalar of the same type and type parameters as a. The function shall be the same on all images and with regards to the arguments mathematically commutative and associative. Note that operator may not be an elemental function, unless it is an intrisic function.
result_image - (optional) a scalar integer expression; if present, it shall have the same the same value on all images and refer to an image of the current team.
stat - (optional) a scalar integer variable
errmsg - (optional) a scalar character variable
http://fortranwiki.org/fortran/show/co_reduce</value>
  </data>
  <data name="intr_co_sum" xml:space="preserve">
    <value>co_sum sums up the values of each element of a on all images of the current team. If result_image is present, the summed-up values are returned in a on the specified image only and the value of a on the other images become undefined. If result_image is not present, the value is returned on all images. If the execution was successful and stat is present, it is assigned the value zero. If the execution failed, stat gets assigned a nonzero value and, if present, errmsg gets assigned a value describing the occurred error.

Standard:
TS 18508 or later

Class:
Collective subroutine

Syntax:
call co_sum(a [, result_image, stat, errmsg])
Arguments:
a - shall be an integer, real or complex variable, which has the same type and type parameters on all images of the team.
result_image - (optional) a scalar integer expression; if present, it shall have the same the same value on all images and refer to an image of the current team.
stat - (optional) a scalar integer variable
errmsg - (optional) a scalar character variable
http://fortranwiki.org/fortran/show/co_sum</value>
  </data>
  <data name="intr_cpu_time" xml:space="preserve">
    <value>Returns a real value representing the elapsed CPU time in seconds. This is useful for testing segments of code to determine execution time.

If a time source is available, time will be reported with microsecond resolution. If no time source is available, time is set to -1.0.

Note that time may contain a, system dependent, arbitrary offset and may not start with 0.0. For cpu_time, the absolute value is meaningless, only differences between subsequent calls to this subroutine, as shown in the example below, should be used.

Standard:
Fortran 95 and later

Class:
Subroutine

Syntax:
call cpu_time(time)

Arguments:
time - The type shall be real with intent(out).

Return value:
None
http://fortranwiki.org/fortran/show/cpu_time</value>
  </data>
  <data name="intr_cshift" xml:space="preserve">
    <value>cshift(array, shift [, dim]) performs a circular shift on elements of array along the dimension of dim. If dim is omitted it is taken to be 1. dim is a scaler of type integer in the range of 1≤DIM≤n where n n is the rank of array. If the rank of array is one, then all elements of array are shifted by shift places. If rank is greater than one, then all complete rank one sections of array along the given dimension are shifted. Elements shifted out one end of each rank one section are shifted back in the other end.

Standard:
Fortran 95 and later

Class:
Transformational function

Syntax:
result = cshift(array, shift [, dim])

Arguments:
array - Shall be an array of any type.
shift - The type shall be integer.
dim - The type shall be integer.

Return value:
Returns an array of same type and rank as the array argument.
http://fortranwiki.org/fortran/show/cshift</value>
  </data>
  <data name="intr_c_associated" xml:space="preserve">
    <value>
c_associated(c_prt_1[, c_ptr_2]) determines the status of the C pointer c_ptr_1 or if c_ptr_1 is associated with the target c_ptr_2.

Standard:
Fortran 2003 and later

Class:
Inquiry function

Syntax:
result = c_associated(c_prt_1[, c_ptr_2])
Arguments:
c_ptr_1 - Scalar of the type c_ptr or c_funptr.
c_ptr_2 - (Optional) Scalar of the same type as c_ptr_1.

Return value:
The return value is of type logical; it is .false. if either c_ptr_1 is a C NULL pointer or if c_ptr1 and c_ptr_2 point to different addresses.
http://fortranwiki.org/fortran/show/c_associated</value>
  </data>
  <data name="intr_c_funloc" xml:space="preserve">
    <value>c_funloc(x) determines the C address of the argument.

Standard:
Fortran 2003 and later

Class:
Inquiry function

Syntax:
result = c_funloc(x)
Arguments:
x - Interoperable function or pointer to such function.

Return value:
The return value is of type c_funptr and contains the C address of the argument.
http://fortranwiki.org/fortran/show/c_funloc</value>
  </data>
  <data name="intr_c_f_pointer" xml:space="preserve">
    <value>c_f_pointer(cptr, fptr[, shape]) Assign the target, the C pointer, cptr to the Fortran pointer fptr and specify its shape.

Standard:
Fortran 2003 and later

Class:
Subroutine

Syntax:
call c_f_pointer(cptr, fptr[, shape])
Arguments:
cptr - scalar of the type c_ptr. It is intent(in).
fptr - pointer interoperable with cptr. It is intent(out).
shape - (Optional) Rank-one array of type integer with intent(in). It shall be present if and only if fptr is an array. The size must be equal to the rank of fptr.
http://fortranwiki.org/fortran/show/c_f_pointer</value>
  </data>
  <data name="intr_c_f_procpointer" xml:space="preserve">
    <value>
c_f_procpointer(cptr, fptr) assigns the target of the C function pointer cptr to the Fortran procedure pointer fptr.

Standard:
Fortran 2003 and later

Class:
Subroutine

Syntax:
call c_f_procpointer(cptr, fptr)

Arguments:
cptr - scalar of the type c_funptr. It is intent(in).
fptr - procedure pointer interoperable with cptr. It is intent(out).
http://fortranwiki.org/fortran/show/c_f_procpointer</value>
  </data>
  <data name="intr_c_loc" xml:space="preserve">
    <value>c_loc(x) determines the C address of the argument.

Standard:
Fortran 2003 and later

Class:
Inquiry function

Syntax:
result = c_loc(x)
Arguments:
x - Shall have either the pointer or target attribute. It shall not be a coindexed object. It shall either be a variable with interoperable type and kind type parameters, or be a scalar, nonpolymorphic variable with no length type parameters.

Return value:
The return value is of type c_ptr and contains the C address of the argument.
http://fortranwiki.org/fortran/show/c_loc</value>
  </data>
  <data name="intr_c_sizeof" xml:space="preserve">
    <value>c_sizeof(x) calculates the number of bytes of storage the expression x occupies.

Standard:
Fortran 2008

Class:
Intrinsic function

Syntax:
n = c_sizeof(x)
Arguments:
x - The argument shall be an interoperable data entity.

Return value:
The return value is of type integer and of the system-dependent kind c_size_t (from the iso_c_binding module). Its value is the number of bytes occupied by the argument. If the argument has the pointer attribute, the number of bytes of the storage area pointed to is returned. If the argument is of a derived type with pointer or allocatable components, the return value does not account for the sizes of the data pointed to by these components.
http://fortranwiki.org/fortran/show/c_sizeof</value>
  </data>
</root>